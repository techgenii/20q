name: Deploy to Lambda

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    env:
      ZIP_FILE: lambda-deploy.zip
      BUILD_DIR: build
      PYTHON_VERSION: 3.13
      HANDLER: app.handler
      RUNTIME: python3.13
      ARCHITECTURE: x86_64
      STAGE_NAME: WhisperChase  # Custom stage name
      FUNCTION_NAME: ${{ secrets.LAMBDA_FUNCTION_NAME }}
      ROLE_ARN: ${{ secrets.LAMBDA_ROLE_ARN }}
      REGION: ${{ secrets.AWS_REGION }}
      S3_BUCKET: ${{ secrets.LAMBDA_S3_BUCKET }}
      API_NAME: WhisperChaseAPI  # Distinct API name

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.REGION }}

      - name: Build Lambda package
        run: |
          cd backend
          rm -rf $BUILD_DIR $ZIP_FILE
          mkdir -p $BUILD_DIR

          pip install -r requirements.txt -t $BUILD_DIR \
            --platform manylinux_2014_x86_64 \
            --only-binary=:all: \
            --no-cache-dir \
            --upgrade \
            --python-version 3.13

          cp app.py game_logic.py supabase_client.py elevenlabs_utils.py __init__.py $BUILD_DIR/
          find $BUILD_DIR \( -name '__pycache__' -o -name '*.pyc' \) -exec rm -rf {} +

      - name: Package deployment
        run: |
          cd backend
          cd $BUILD_DIR
          zip -r9 ../$ZIP_FILE .
          cd ..
          echo "size=$(du -h $ZIP_FILE | cut -f1)" >> $GITHUB_OUTPUT

      - name: Deploy Lambda Function
        run: |
          cd backend
          
          # Handle environment variables properly
          if [ -n "$LAMBDA_ENV_VARS" ] && [ "$LAMBDA_ENV_VARS" != "{}" ]; then
            # If LAMBDA_ENV_VARS is provided, wrap it in Variables object
            echo "{\"Variables\": $LAMBDA_ENV_VARS}" > env.json
          else
            # Create empty environment variables
            echo '{"Variables": {}}' > env.json
          fi
          
          # Debug: show what we're creating
          echo "Environment configuration:"
          cat env.json
          
          if aws lambda get-function --function-name $FUNCTION_NAME &>/dev/null; then
            echo "Updating existing function..."
            aws lambda update-function-code \
              --function-name $FUNCTION_NAME \
              --zip-file fileb://$ZIP_FILE
            aws lambda update-function-configuration \
              --function-name $FUNCTION_NAME \
              --environment file://env.json
          else
            echo "Creating new function..."
            aws lambda create-function \
              --function-name $FUNCTION_NAME \
              --runtime $RUNTIME \
              --role $ROLE_ARN \
              --handler $HANDLER \
              --architectures $ARCHITECTURE \
              --zip-file fileb://$ZIP_FILE \
              --environment file://env.json
          fi
          aws lambda wait function-updated --function-name $FUNCTION_NAME
        env:
          LAMBDA_ENV_VARS: ${{ secrets.LAMBDA_ENV_VARS || '{}' }}

      - name: Configure API Gateway
        run: |
          # Check if API already exists
          EXISTING_API_ID=$(aws apigatewayv2 get-apis --query "Items[?Name=='$API_NAME'].ApiId" --output text 2>/dev/null || echo "")
          
          if [ -n "$EXISTING_API_ID" ] && [ "$EXISTING_API_ID" != "None" ]; then
            echo "Using existing API Gateway: $EXISTING_API_ID"
            API_ID=$EXISTING_API_ID
          else
            echo "Creating new API Gateway..."
            API_ID=$(aws apigatewayv2 create-api \
              --name "$API_NAME" \
              --protocol-type HTTP \
              --query "ApiId" --output text)
            echo "Created API Gateway: $API_ID"
          fi
          
          # Check if integration already exists
          EXISTING_INTEGRATION_ID=$(aws apigatewayv2 get-integrations --api-id $API_ID --query "Items[0].IntegrationId" --output text 2>/dev/null || echo "")
          
          if [ -n "$EXISTING_INTEGRATION_ID" ] && [ "$EXISTING_INTEGRATION_ID" != "None" ]; then
            echo "Using existing integration: $EXISTING_INTEGRATION_ID"
            INTEGRATION_ID=$EXISTING_INTEGRATION_ID
          else
            echo "Creating new integration..."
            ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
            LAMBDA_ARN="arn:aws:lambda:$REGION:$ACCOUNT_ID:function:$FUNCTION_NAME"
            
            INTEGRATION_ID=$(aws apigatewayv2 create-integration \
              --api-id $API_ID \
              --integration-type AWS_PROXY \
              --integration-uri $LAMBDA_ARN \
              --payload-format-version 2.0 \
              --query 'IntegrationId' --output text)
            echo "Created integration: $INTEGRATION_ID"
          fi

          # Create routes (these will be updated if they exist)
          echo "Setting up routes..."
          aws apigatewayv2 create-route \
            --api-id $API_ID \
            --route-key "ANY /" \
            --target "integrations/$INTEGRATION_ID" 2>/dev/null || echo "Route ANY / already exists"
            
          aws apigatewayv2 create-route \
            --api-id $API_ID \
            --route-key "ANY /{proxy+}" \
            --target "integrations/$INTEGRATION_ID" 2>/dev/null || echo "Route ANY /{proxy+} already exists"
          
          # Create or update stage
          echo "Setting up stage..."
          aws apigatewayv2 create-stage \
            --api-id $API_ID \
            --stage-name $STAGE_NAME \
            --auto-deploy 2>/dev/null || echo "Stage $STAGE_NAME already exists"
          
          # Set permissions (will fail silently if already exists)
          echo "Setting up Lambda permissions..."
          aws lambda add-permission \
            --function-name $FUNCTION_NAME \
            --statement-id "api-gateway-invoke" \
            --action lambda:InvokeFunction \
            --principal apigateway.amazonaws.com \
            --source-arn "arn:aws:execute-api:$REGION:$ACCOUNT_ID:$API_ID/$STAGE_NAME/*" 2>/dev/null || echo "Permission already exists"

          # Output endpoint
          ENDPOINT="https://$API_ID.execute-api.$REGION.amazonaws.com/$STAGE_NAME"
          echo "API_ENDPOINT=$ENDPOINT" >> $GITHUB_ENV
          echo "endpoint=$ENDPOINT" >> $GITHUB_OUTPUT
          echo "API Gateway configured successfully!"
          echo "Endpoint: $ENDPOINT"

      - name: Post deployment test
        run: |
          echo "Testing API endpoint..."
          # Test the root endpoint instead of /health
          curl -s $API_ENDPOINT --max-time 10 || echo "API test failed (this is normal for the first deployment)"
          echo "WhisperChase stage deployed successfully!"
          echo "Access your API at: $API_ENDPOINT"