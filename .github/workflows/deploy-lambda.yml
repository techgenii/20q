name: Step 2 - Deploy to Lambda

on:
  workflow_run:
    workflows: ["Step 1 - Test Backend"]
    types:
      - completed
  workflow_dispatch:

jobs:
  deploy-code:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    env:
      ZIP_FILE: lambda-deploy.zip
      BUILD_DIR: build
      PYTHON_VERSION: 3.13
      HANDLER: app.handler
      RUNTIME: python3.13
      STAGE_NAME: '$default'
      FUNCTION_NAME: ${{ secrets.FUNCTION_NAME }}
      ROLE_ARN: ${{ secrets.LAMBDA_ROLE_ARN }}
      REGION: ${{ secrets.AWS_REGION }}
      API_GATEWAY_NAME: ${{ secrets.API_GATEWAY_NAME || 'MyAPI' }}

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}

      - name: Prepare build directory
        run: |
          rm -rf $BUILD_DIR $ZIP_FILE venv
          python -m venv venv
          source venv/bin/activate
          mkdir -p $BUILD_DIR
          
          # Upgrade pip and install build tools
          pip install --upgrade pip setuptools wheel
          
          # Install dependencies with platform-specific builds for Lambda
          # Use --no-deps to avoid metadata issues, then install dependencies manually
          pip install -r backend/requirements.txt -t $BUILD_DIR \
            --platform manylinux2014_x86_64 \
            --only-binary=:all: \
            --upgrade \
            --force-reinstall
          
          # Fix email-validator metadata issue specifically
          pip install email-validator -t $BUILD_DIR \
            --platform manylinux2014_x86_64 \
            --only-binary=:all: \
            --upgrade \
            --force-reinstall \
            --no-cache-dir
          
          # Copy application code
          cp -r backend/. $BUILD_DIR/
          
          # Create a simple __init__.py in the root if it doesn't exist
          touch $BUILD_DIR/__init__.py
          
          # Remove unnecessary files to reduce package size but keep metadata
          find $BUILD_DIR -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
          find $BUILD_DIR -type f -name "*.pyc" -delete 2>/dev/null || true
          find $BUILD_DIR -type d -name "tests" -exec rm -rf {} + 2>/dev/null || true
          # Keep .dist-info directories for metadata
          
          deactivate

      - name: Check build contents
        run: |
          echo "Build directory contents:"
          ls -la $BUILD_DIR/
          
          if [ ! -f "$BUILD_DIR/app.py" ]; then
            echo "‚ùå app.py not found at root of build dir!"
            echo "Available files:"
            find $BUILD_DIR -name "*.py" -type f
            exit 1
          fi
          
          # Check if handler function exists
          if ! grep -q "def handler" "$BUILD_DIR/app.py"; then
            echo "‚ö†Ô∏è  Warning: 'handler' function not found in app.py"
            echo "Available functions:"
            grep "^def " "$BUILD_DIR/app.py" || echo "No functions found"
          fi
          
          # Check for email-validator specifically
          echo "Checking for email-validator installation..."
          if [ -d "$BUILD_DIR/email_validator" ] || find $BUILD_DIR -name "*email*validator*" -type d | head -1; then
            echo "‚úÖ email-validator found"
          else
            echo "‚ùå email-validator not found - this may cause import errors"
          fi
          
          # List all installed packages for debugging
          echo "Installed packages:"
          find $BUILD_DIR -maxdepth 1 -type d -name "*" | grep -E "\.(dist-info|egg-info)$" | head -10

      - name: Zip Lambda package
        run: |
          cd $BUILD_DIR
          zip -r9 ../lambda-deploy.zip . -x "*.git*" "*.DS_Store*"
          cd ..
          
          # Check zip file size (Lambda has a 50MB limit for direct upload)
          ZIP_SIZE=$(stat -f%z lambda-deploy.zip 2>/dev/null || stat -c%s lambda-deploy.zip)
          ZIP_SIZE_MB=$((ZIP_SIZE / 1024 / 1024))
          echo "Lambda package size: ${ZIP_SIZE_MB}MB"
          
          if [ $ZIP_SIZE_MB -gt 50 ]; then
            echo "‚ùå Package too large (${ZIP_SIZE_MB}MB). Consider using S3 for deployment."
            exit 1
          fi

      - name: Verify Lambda package exists
        run: |
          if [ ! -f lambda-deploy.zip ]; then
            echo "‚ùå ERROR: Lambda deployment package not found."
            exit 1
          fi

      - uses: actions/upload-artifact@v4
        with:
          name: lambda-deploy
          path: lambda-deploy.zip

      - name: Configure AWS CLI
        run: |
          aws configure set aws_access_key_id ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws configure set aws_secret_access_key ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws configure set region $REGION
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Deploy Lambda Function
        run: |
          echo "Deploying Lambda function: $FUNCTION_NAME"
          
          # Check if function exists
          set +e
          FUNCTION_INFO=$(aws lambda get-function --function-name $FUNCTION_NAME 2>/dev/null)
          FUNCTION_EXISTS=$?
          set -e

          if [ $FUNCTION_EXISTS -ne 0 ]; then
            echo "Creating new Lambda function..."
            aws lambda create-function \
              --function-name $FUNCTION_NAME \
              --runtime $RUNTIME \
              --role $ROLE_ARN \
              --handler $HANDLER \
              --zip-file fileb://lambda-deploy.zip \
              --timeout 30 \
              --memory-size 128 \
              --environment Variables='{PYTHONPATH="/var/task:/var/runtime"}' \
              --description "Deployed via GitHub Actions"
          else
            echo "Updating existing Lambda function..."
            
            # Get existing environment variables to preserve them
            EXISTING_ENV=$(echo "$FUNCTION_INFO" | jq -r '.Configuration.Environment.Variables // {}')
            echo "Preserving existing environment variables: $EXISTING_ENV"
            
            # Update function code first
            aws lambda update-function-code \
              --function-name $FUNCTION_NAME \
              --zip-file fileb://lambda-deploy.zip
              
            # Wait for code update to complete
            aws lambda wait function-updated --function-name $FUNCTION_NAME
            
            # Update function configuration while preserving existing env vars
            UPDATED_ENV=$(echo "$EXISTING_ENV" | jq '. + {"PYTHONPATH": "/var/task:/var/runtime"}')
            aws lambda update-function-configuration \
              --function-name $FUNCTION_NAME \
              --timeout 30 \
              --memory-size 128 \
              --environment Variables="$UPDATED_ENV"
          fi
          
          # Wait for the function to be active
          echo "Waiting for function to be active..."
          aws lambda wait function-active --function-name $FUNCTION_NAME

      - name: Setup API Gateway
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "Account ID: $ACCOUNT_ID"
          
          # Check if API exists
          API_ID=$(aws apigatewayv2 get-apis --query "Items[?Name=='$API_GATEWAY_NAME'].ApiId" --output text)
          
          if [ -z "$API_ID" ] || [ "$API_ID" = "None" ]; then
            echo "Creating new API Gateway..."
            API_ID=$(aws apigatewayv2 create-api \
              --name "$API_GATEWAY_NAME" \
              --protocol-type HTTP \
              --description "API for $FUNCTION_NAME" \
              --query "ApiId" --output text)
            echo "Created API with ID: $API_ID"
          else
            echo "Using existing API with ID: $API_ID"
          fi

          # Check if integration already exists for this function
          LAMBDA_URI="arn:aws:lambda:$REGION:$ACCOUNT_ID:function:$FUNCTION_NAME"
          EXISTING_INTEGRATION=$(aws apigatewayv2 get-integrations --api-id $API_ID --query "Items[?IntegrationUri=='$LAMBDA_URI'].IntegrationId" --output text)
          
          if [ -n "$EXISTING_INTEGRATION" ] && [ "$EXISTING_INTEGRATION" != "None" ]; then
            echo "Using existing integration: $EXISTING_INTEGRATION"
            INTEGRATION_ID="$EXISTING_INTEGRATION"
          else
            echo "Creating new integration..."
            INTEGRATION_ID=$(aws apigatewayv2 create-integration \
              --api-id $API_ID \
              --integration-type AWS_PROXY \
              --integration-uri $LAMBDA_URI \
              --payload-format-version 2.0 \
              --query 'IntegrationId' --output text)
            echo "Created integration with ID: $INTEGRATION_ID"
          fi

          # Check and create routes only if they don't exist
          ROOT_ROUTE_EXISTS=$(aws apigatewayv2 get-routes --api-id $API_ID --query "Items[?RouteKey=='ANY /'] | length(@)" --output text)
          if [ "$ROOT_ROUTE_EXISTS" -eq 0 ]; then
            echo "Creating root route..."
            aws apigatewayv2 create-route \
              --api-id $API_ID \
              --route-key "ANY /" \
              --target integrations/$INTEGRATION_ID
          else
            echo "Root route already exists, skipping creation."
          fi
            
          PROXY_ROUTE_EXISTS=$(aws apigatewayv2 get-routes --api-id $API_ID --query "Items[?RouteKey=='ANY /{proxy+}'] | length(@)" --output text)
          if [ "$PROXY_ROUTE_EXISTS" -eq 0 ]; then
            echo "Creating proxy route..."
            aws apigatewayv2 create-route \
              --api-id $API_ID \
              --route-key "ANY /{proxy+}" \
              --target integrations/$INTEGRATION_ID
          else
            echo "Proxy route already exists, skipping creation."
          fi
          
          # Check if stage exists
          set +e
          aws apigatewayv2 get-stage --api-id $API_ID --stage-name $STAGE_NAME > /dev/null 2>&1
          STAGE_EXISTS=$?
          set -e
          
          if [ $STAGE_EXISTS -ne 0 ]; then
            echo "Creating stage '$STAGE_NAME'..."
            aws apigatewayv2 create-stage \
              --api-id $API_ID \
              --stage-name $STAGE_NAME \
              --auto-deploy
          else
            echo "Stage '$STAGE_NAME' already exists, skipping creation."
          fi

          # Add Lambda permission for API Gateway (use unique statement ID)
          STATEMENT_ID="apigateway-access-$(date +%s)"
          echo "Adding Lambda permission with statement ID: $STATEMENT_ID"
          set +e
          aws lambda add-permission \
            --function-name $FUNCTION_NAME \
            --statement-id "$STATEMENT_ID" \
            --action lambda:InvokeFunction \
            --principal apigateway.amazonaws.com \
            --source-arn "arn:aws:execute-api:$REGION:$ACCOUNT_ID:$API_ID/*/*" \
            2>/dev/null
          PERMISSION_RESULT=$?
          set -e
          
          if [ $PERMISSION_RESULT -eq 0 ]; then
            echo "Lambda permission added successfully."
          else
            echo "Lambda permission already exists or couldn't be added, continuing..."
          fi

          # Output the API endpoint (no stage in URL for $default stage)
          if [ "$STAGE_NAME" = '$default' ]; then
            API_ENDPOINT="https://$API_ID.execute-api.$REGION.amazonaws.com"
          else
            API_ENDPOINT="https://$API_ID.execute-api.$REGION.amazonaws.com/$STAGE_NAME"
          fi
          
          echo "üöÄ Deployment successful!"
          echo "API Endpoint: $API_ENDPOINT"
          
          # Test the endpoint
          echo "Testing endpoint..."
          set +e
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$API_ENDPOINT" --max-time 10)
          CURL_EXIT=$?
          set -e
          
          if [ $CURL_EXIT -eq 0 ]; then
            if [ "$HTTP_STATUS" -eq 200 ] || [ "$HTTP_STATUS" -eq 404 ] || [ "$HTTP_STATUS" -eq 500 ]; then
              echo "‚úÖ Endpoint is responding (HTTP $HTTP_STATUS)"
            else
              echo "‚ö†Ô∏è  Endpoint returned HTTP $HTTP_STATUS"
            fi
          else
            echo "‚ö†Ô∏è  Could not test endpoint (timeout or connection error)"
          fi